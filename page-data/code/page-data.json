{"componentChunkName":"component---src-templates-doc-tsx","path":"/code/","result":{"data":{"doc":{"frontmatter":{"title":"Code","date":null,"permalink":"/code/","byline":null,"guestBio":null,"sublinks":null,"layout":"code"},"id":"0339cad0-8bd2-5bb3-be8b-0bc3fc6783a6","rawMarkdownBody":"\nGraphQL 已有多种编程语言支持。下表包含一些流行的服务端框架、客户端库、服务和其他有用的内容。\n\n## 服务端库\n\n除了 GraphQL [JavaScript 参考实现](#javascript)，还有其他服务端库：\n\n- [C# / .NET](#c#-/-.net)\n- [Clojure](#clojure)\n- [D](#d)\n- [Elixir](#elixir)\n- [Erlang](#erlang)\n- [Go](#go)\n- [Groovy](#groovy)\n- [Haskell](#haskell)\n- [Java](#java)\n- [JavaScript](#javascript)\n- [Kotlin](#kotlin)\n- [Perl](#perl)\n- [PHP](#php)\n- [Python](#python)\n- [Ruby](#ruby)\n- [Rust](#rust)\n- [Scala](#scala)\n- [Swift](#swift)\n- [OCaml / Reason](#ocaml-reason)\n\n### C# / .NET\n\n#### [graphql-dotnet](https://github.com/graphql-dotnet/graphql-dotnet)：.NET 的 GraphQL 实现\n\n```csharp\nusing System;\nusing GraphQL;\nusing GraphQL.Types;\n\npublic class Program\n{\n  public static void Main(string[] args)\n  {\n    var schema = Schema.For(@\"\n      type Query {\n        hello: String\n      }\n    \");\n    var json = schema.Execute(_ =>\n    {\n      _.Query = \"{ hello }\";\n      _.Root = new { Hello = \"Hello World!\" };\n    });\n    Console.WriteLine(json);\n  }\n}                   \n```\n\n  - [graphql-net](https://github.com/ckimes89/graphql-net)：转换 GraphQL 到 IQueryable\n  - [Entity GraphQL](https://github.com/lukemurray/EntityGraphQL)：针对 .NET Core 的 GraphQL 库。编译为 IQueryable 以轻松地从现有的数据模型（例如从 Entity Framework 数据模型）中暴露出 schema\n  - [DotNetGraphQLQueryGen](https://github.com/lukemurray/DotNetGraphQLQueryGen)：从 GraphQL schema 生成类，以在 dotnet 中进行类型安全的查询的 .NET Core 库\n  - [Hot Chocolate](https://github.com/ChilliCream/hotchocolate)：针对 .NET core 和 .NET classic 的 GraphQL 服务器\n  - [NGraphQL](https://github.com/rivantsov/starwars)：用于 .NET Core 和完整框架的 GraphQL 服务器\n\n### Clojure\n\n#### [alumbra](https://github.com/alumbra/alumbra)\n\n一套 Clojure 的 GraphQL 可复用组件，满足 [alumbra.spec](https://github.com/alumbra/alumbra.spec) 规范要求的数据结构。\n\n```clojure\n(require '[alumbra.core :as alumbra]\n         '[claro.data :as data])\n\n(def schema\n  \"type Person { name: String!, friends: [Person!]! }\n   type QueryRoot { person(id: ID!): Person, me: Person! }\n   schema { query: QueryRoot }\")\n\n(defrecord Person [id]\n  data/Resolvable\n  (resolve! [_ _]\n    {:name    (str \"Person #\" id)\n     :friends (map ->Person  (range (inc id) (+ id 3)))}))\n\n(def QueryRoot\n  {:person (map->Person {})\n   :me     (map->Person {:id 0})})\n\n(def app\n  (alumbra/handler\n    {:schema schema\n     :query  QueryRoot}))\n\n(defonce my-graphql-server\n  (aleph.http/start-server #'app {:port 3000}))\n```\n\n```bash\n$ curl -XPOST \"http://0:3000\" -H'Content-Type: application/json' -d'{\n  \"query\": \"{ me { name, friends { name } } }\"\n}'\n{\"data\":{\"me\":{\"name\":\"Person #0\",\"friends\":[{\"name\":\"Person #1\"},{\"name\":\"Person #2\"}]}}}\n```\n\n#### [graphql-clj](https://github.com/tendant/graphql-clj)\n\n一个提供 GraphQL 实现的 Clojure 库。\n\n可以执行一个 \\`hello world\\` GraphQL 查询的 \\`graphql-clj\\` 代码如下：\n\n```clojure\n\n(def schema \"type QueryRoot {\n    hello: String\n  }\")\n\n(defn resolver-fn [type-name field-name]\n  (get-in {\"QueryRoot\" {\"hello\" (fn [context parent & rest]\n                              \"Hello world!\")}}\n          [type-name field-name]))\n\n(require '[graphql-clj.executor :as executor])\n\n(executor/execute nil schema resolver-fn \"{ hello }\")\n```\n\n#### [lacinia](https://github.com/walmartlabs/lacinia)\n\n一套 GraphQL 规范的完整实现，致力于维护对规范的外部兼容。\n\n### D\n\n  - [graphqld](https://github.com/burner/graphqld)：D 编程语言的 GraphQL 实现。\n\n### Elixir\n\n  - [absinthe](https://github.com/absinthe-graphql/absinthe)：Elixir 的 GraphQL 实现。\n  - [graphql-elixir](https://github.com/graphql-elixir/graphql)：一个 Facebook GraphQL 的 Elixir 实现。\n\n### Erlang\n\n  - [graphql-erlang](https://github.com/shopgun/graphql-erlang)：Erlang 的 GraphQL 实现。\n\n### Go\n\n  - [graphql-go](https://github.com/graphql-go/graphql)：一个 Go/Golang 的 GraphQL 实现。\n  - [graph-gophers/graphql-go](https://github.com/graph-gophers/graphql-go)：一个活跃的 Golang GraphQL 实现。\n  - [99designs/gqlgen](https://github.com/99designs/gqlgen)：生成基于 graphql 的服务器的库。\n  - [graphql-relay-go](https://github.com/graphql-go/relay)：一个用于帮助构建 graphql-go 服务器的 Go/Golang 库，支持 react-relay。\n  - [samsarahq/thunder](https://github.com/samsarahq/thunder)：可轻松进行 schema 构建、实时查询和批处理的 GraphQL 实现。\n  - [appointy/jaal](https://github.com/appointy/jaal)：在 Go 中开发符合规范的 GraphQL 服务器。\n\n### Groovy\n\n#### [gorm-graphql](https://github.com/grails/gorm-graphql/)\n\n**核心库** —— GORM GraphQL 库提供了基于你的 GORM 实体来生成 GraphQL schema 的功能。除了能够将域类映射到 GraphQL schema 之外，核心库还提供了通过 schema 的执行来查询、更新和删除数据的“数据访问者”的默认实现。\n\n**Grails 插件** —— 作为对核心库的补充，GORM GraphQL Grails 插件能够：\n\n- 提供一个通过 HTTP 来接收和响应 GraphQL 请求的控制器。\n- 在启动时使用 spring bean 配置生成 schema，以便于扩展。\n- 包含一个在开发环境下默认启用的 [GraphiQL](https://github.com/graphql/graphiql) 浏览器。这一浏览器可以在 /graphql/browser 下访问。\n- 使用 Grails 提供的数据绑定覆盖默认的数据绑定\n- 提供一个 [特质](https://grails.github.io/gorm-graphql/latest/api/org/grails/gorm/graphql/plugin/testing/GraphQLSpec.html) 以使你更容易对 GraphQL 入口端点进行集成测试\n\n更多信息请查看 [文档](https://grails.github.io/gorm-graphql/latest/guide/index.html)。\n\n#### [GQL](https://grooviter.github.io/gql/)\n\nGQL 是一个在 Groovy 中使用 GraphQL 的库。\n\n### Haskell\n\n#### [Morpheus GraphQL](https://github.com/morpheusgraphql/morpheus-graphql)\n\n用于构建 GraphQL API 的 Haskell 库。\n\n一个使用 `morpheus-graphql` 的 hello world 示例：\n\n```graphql\n# schema.gql\n\"\"\"\nA supernatural being considered divine and sacred\n\"\"\"\ntype Deity {\n  name: String!\n  power: String @deprecated(reason: \"no more supported\")\n}\ntype Query {\n  deity(name: String! = \"Morpheus\"): Deity!\n}\n```\n\n```haskell\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE DuplicateRecordFields #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE NamedFieldPuns #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeFamilies #-}\nmodule API (api) where\nimport Data.ByteString.Lazy.Char8 (ByteString)\nimport Data.Morpheus (interpreter)\nimport Data.Morpheus.Document (importGQLDocument)\nimport Data.Morpheus.Types (RootResolver (..), Undefined (..))\nimport Data.Text (Text)\nimportGQLDocument \"schema.gql\"\nrootResolver :: RootResolver IO () Query Undefined Undefined\nrootResolver =\n  RootResolver\n    { queryResolver = Query {deity},\n      mutationResolver = Undefined,\n      subscriptionResolver = Undefined\n    }\n  where\n    deity DeityArgs {name} =\n      pure\n        Deity\n          { name = pure name,\n            power = pure (Just \"Shapeshifting\")\n          }\napi :: ByteString -> IO ByteString\napi = interpreter rootResolver\n```\n\n查看 [morpheus-graphql-examples](https://github.com/morpheusgraphql/morpheus-graphql) 了解更复杂的 API。\n  \n### Java\n\n#### [graphql-java](https://github.com/graphql-java/graphql-java)\n\n一个用于构建 GraphQL API 的 Java 库。\n\n可以执行一个 `hello world` GraphQL 查询的 `graphql-java` 代码如下：\n\n```java\nimport graphql.ExecutionResult;\nimport graphql.GraphQL;\nimport graphql.schema.GraphQLSchema;\nimport graphql.schema.StaticDataFetcher;\nimport graphql.schema.idl.RuntimeWiring;\nimport graphql.schema.idl.SchemaGenerator;\nimport graphql.schema.idl.SchemaParser;\nimport graphql.schema.idl.TypeDefinitionRegistry;\n\nimport static graphql.schema.idl.RuntimeWiring.newRuntimeWiring;\n\npublic class HelloWorld {\n\n    public static void main(String[] args) {\n        String schema = \"type Query{hello: String} schema{query: Query}\";\n\n        SchemaParser schemaParser = new SchemaParser();\n        TypeDefinitionRegistry typeDefinitionRegistry = schemaParser.parse(schema);\n\n        RuntimeWiring runtimeWiring = new RuntimeWiring()\n                .type(\"Query\", builder -> builder.dataFetcher(\"hello\", new StaticDataFetcher(\"world\")))\n                .build();\n\n        SchemaGenerator schemaGenerator = new SchemaGenerator();\n        GraphQLSchema graphQLSchema = schemaGenerator.makeExecutableSchema(typeDefinitionRegistry, runtimeWiring);\n\n        GraphQL build = GraphQL.newGraphQL(graphQLSchema).build();\n        ExecutionResult executionResult = build.execute(\"{hello}\");\n\n        System.out.println(executionResult.getData().toString());\n        // Prints: {hello=world}\n    }\n}\n```\n\n查看 [graphql-java 文档](https://github.com/graphql-java/graphql-java) 以了解更多信息。\n\n### JavaScript\n\n#### [GraphQL.js](/graphql-js/) ([github](https://github.com/graphql/graphql-js/)) ([npm](https://www.npmjs.com/package/graphql))\n\nGraphQL 规范的参考实现，设计用于在 Node.js 环境中运行。\n\n如果要在命令行中运行一个 `GraphQL.js` 的 hello world 脚本：\n\n```bash\nnpm install graphql\n```\n\n然后使用 `node hello.js` 以运行 `hello.js` 中的代码：\n\n```js\nvar { graphql, buildSchema } = require('graphql');\n\nvar schema = buildSchema(`\n  type Query {\n    hello: String\n  }\n`);\n\nvar root = { hello: () => 'Hello world!' };\n\ngraphql(schema, '{ hello }', root).then((response) => {\n  console.log(response);\n});\n```\n\n#### [express-graphql](/graphql-js/running-an-express-graphql-server/) ([github](https://github.com/graphql/express-graphql)) ([npm](https://www.npmjs.com/package/express-graphql))\n\n基于 Express webserver 服务器的一个 GraphQL API 服务端参考实现，你可以用它结合常规 Express webserver 来运行 GraphQL，也可以作为独立 GraphQL 服务器。\n\n如果要运行 `express-graphql` 的 hello world 服务器：\n\n```bash\nnpm install express express-graphql graphql\n```\n\n然后使用 `node server.js` 以运行 `server.js` 中的代码：\n\n```js\nvar express = require('express');\nvar { graphqlHTTP } = require('express-graphql');\nvar { buildSchema } = require('graphql');\n\nvar schema = buildSchema(`\n  type Query {\n    hello: String\n  }\n`);\n\nvar root = { hello: () => 'Hello world!' };\n\nvar app = express();\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true,\n}));\napp.listen(4000, () => console.log('Now browse to localhost:4000/graphql'));\n```\n\n#### [apollo-server](https://www.apollographql.com/docs/apollo-server/) ([github](https://github.com/apollographql/apollo-server)) ([npm](https://www.npmjs.com/package/apollo-server-express))\n\n来自于 Apollo 的一套 GraphQL server 包，可用于多种 Node.js HTTP 框架（Express，Connect，Hapi，Koa 等）。\n\n如果要运行 `apollo-server-express` 的 hello world 服务器：\n\n```bash\nnpm install apollo-server-express express\n```\n\n然后使用 `node server.js` 以运行 `server.js` 中的代码：\n\n```js\nconst express = require('express');\nconst { ApolloServer, gql } = require('apollo-server-express');\n\nconst typeDefs = gql`\n  type Query {\n    hello: String\n  }\n`;\n\nconst resolvers = {\n  Query: {\n    hello: () => 'Hello world!',\n  },\n};\nconst server = new ApolloServer({ typeDefs, resolvers });\nconst app = express();\nserver.applyMiddleware({ app });\napp.listen({ port: 4000 }, () =>\n  console.log('Now browse to http://localhost:4000' + server.graphqlPath)\n);\n```\n\nApollo Server 也支持所有的 Node.js HTTP 服务器框架：Express、Connect、HAPI、Koa 和 NestJs。\n\n### Kotlin\n\n  - [graphql-kotlin](https://github.com/ExpediaGroup/graphql-kotlin/)：一组用于在 Kotlin 中运行 GraphQL 服务器的库。\n  - [KGraphQL](https://github.com/aPureBase/KGraphQL)：设置 GraphQL 服务器的一个纯 Kotlin 实现。\n\n### Perl\n\n  - [graphql-perl](https://github.com/graphql-perl/graphql-perl)：GraphQL 参考实现的 Perl 移植版本\n    - [MetaCPAN documentation](https://metacpan.org/pod/GraphQL)\n    - [Mojolicious-Plugin-GraphQL](https://github.com/graphql-perl/Mojolicious-Plugin-GraphQL)：将你的 GraphQL 服务连接到 Mojolicious 应用\n    - [GraphQL-Plugin-Convert-DBIC](https://github.com/graphql-perl/GraphQL-Plugin-Convert-DBIC)：自动将你的 DBIx::Class schema 连接到 GraphQL\n    - [GraphQL-Plugin-Convert-OpenAPI](https://github.com/graphql-perl/GraphQL-Plugin-Convert-OpenAPI)：自动将任何 OpenAPI 服务（本地或远程的 Mojolicious）连接到GraphQL\n\n### PHP\n\n  - [graphql-php](https://github.com/webonyx/graphql-php)：GraphQL 参考实现的 PHP 移植版本\n  - [graphql-relay-php](https://github.com/ivome/graphql-relay-php)：一个用于辅助构建 graphql-php 服务器的库，支持 react-relay\n  - [Railt](https://github.com/railt/railt)：一个 PHP GraphQL 框架\n  - [Lighthouse](https://github.com/nuwave/lighthouse)：一个用于 Laravel 的 GraphQL 服务器\n  - [GraphQLBundle](https://github.com/overblog/GraphQLBundle)：一个用于 Symfony 的 GraphQL 服务器\n  - [WPGraphQL](https://github.com/wp-graphql/wp-graphql)：一个免费的开源 WordPress 插件，可为任何 WordPress 网站提供可扩展的 GraphQL schema 和 API\n  - [GraphQL API for WordPress](https://github.com/GraphQLAPI/graphql-api-for-wp)：WordPress 的 GraphQL 服务器\n  - [GraPHPinator](https://github.com/infinityloop-dev/graphpinator)：现代 PHP 的一个 GraphQL 实现\n\n#### [API Platform](https://api-platform.com) ([github](https://github.com/api-platform/api-platform))\n\nAPI Platform 是一个基于 Symfony 构建的功能齐全、灵活且可扩展的 API 框架。\n以下的类足以创建与 Relay 兼容的 GraphQL 服务器和支持现代 REST 格式（JSON-LD、JSONAPI...）的超媒体 API：\n\n```php\n<?php\n\nnamespace App\\Entity;\n\nuse ApiPlatform\\Core\\Annotation\\ApiResource;\nuse Doctrine\\ORM\\Mapping as ORM;\n\n/**\n * Greet someone!\n *\n * @ApiResource\n * @ORM\\Entity\n */\nclass Greeting\n{\n    /**\n     * @ORM\\Id\n     * @ORM\\Column(type=\"guid\")\n     */\n    public $id;\n\n    /**\n     * @var string Your nice message\n     *\n     * @ORM\\Column\n     */\n    public $hello;\n}\n```\n\nAPI Platform 的其他功能还包括数据验证、身份验证、授权、弃用、缓存和 GraphiQL 集成。\n\n#### [GraphQLite](https://graphqlite.thecodingmachine.io) ([github](https://github.com/thecodingmachine/graphqlite))\n\nGraphQLite 是一个为 GraphQL schema 定义提供基于注释的语法的库。\n它与框架无关，可用于 Symfony 和 Laravel。\n\n以下的代码声明了一个 “product” 查询和一个 “Product” 类型：\n\n```php\nclass ProductController\n{\n    /**\n     * @Query()\n     */\n    public function product(string $id): Product\n    {\n        // Some code that looks for a product and returns it.\n    }\n}\n\n/**\n * @Type()\n */\nclass Product\n{\n    /**\n     * @Field()\n     */\n    public function getName(): string\n    {\n        return $this->name;\n    }\n    // ...\n}\n```\n\nGraphQLite 的其他功能包括验证、安全性、错误处理、通过数据加载器模式加载……\n\n#### [Siler](https://siler.leocavalcante.com/graphql/) ([github](https://github.com/leocavalcante/siler))\n\nSiler 是一个具有高级抽象功能，可与 GraphQL 搭配使用的 PHP 库。\n\n如果要运行 Siler 的 hello world 脚本：\n\n```graphql\ntype Query {\n  hello: String\n}\n```\n\n```php\n<?php\ndeclare(strict_types=1);\nrequire_once '/path/to/vendor/autoload.php';\n\nuse Siler\\Diactoros;\nuse Siler\\Graphql;\nuse Siler\\Http;\n\n$typeDefs = file_get_contents(__DIR__.'/schema.graphql');\n$resolvers = [\n    'Query' => [\n        'hello' => 'world',\n    ],\n];\n$schema = Graphql\\schema($typeDefs, $resolvers);\n\necho \"Server running at http://127.0.0.1:8080\";\nHttp\\server(Graphql\\psr7($schema), function (\\Throwable $err) {\n    var_dump($err);\n    return Diactoros\\json([\n        'error'   => true,\n        'message' => $err->getMessage(),\n    ]);\n})()->run();\n```\n\n它还根据 Apollo 的工作原理提供了构建 WebSocket 订阅服务器的功能。\n\n### Swift\n\n  - [Graphiti](https://github.com/GraphQLSwift/Graphiti)：一个 Swift 库，可快速、安全且轻松地构建 GraphQL schema/类型。\n\n### Python\n\n#### [Graphene](http://graphene-python.org/) ([github](https://github.com/graphql-python/graphene))\n\n一个用于构建 GraphQL API 的 Python 库。\n\n如果要运行一个 Graphene hello world 脚本：\n\n```bash\npip install graphene\n```\n\n然后使用 `python hello.py` 以运行 `hello.py` 中的代码：\n\n```python\nimport graphene\n\nclass Query(graphene.ObjectType):\n  hello = graphene.String(name=graphene.String(default_value=\"World\"))\n\n  def resolve_hello(self, info, name):\n    return 'Hello ' + name\n\nschema = graphene.Schema(query=Query)\nresult = schema.execute('{ hello }')\nprint(result.data['hello']) # \"Hello World\"\n```\n\n其也有对 [Relay](https://facebook.github.io/relay/)、Django、SQLAlchemy 和 Google App Engine 的良好绑定。\n\n### Ruby\n\n#### [graphql-ruby](https://github.com/rmosolgo/graphql-ruby)\n\n一个用于构建 GraphQL API 的 Ruby 库。\n\n如果要使用 `graphql-ruby` 运行一个 hello world 脚本：\n\n```bash\ngem install graphql\n```\n\n然后使用 `ruby hello.rb` 运行 `hello.rb` 中的代码：\n\n```ruby\nrequire 'graphql'\n\nclass QueryType < GraphQL::Schema::Object\n  graphql_name 'Query'\n  field :hello do\n    type types.String\n    resolve -> (obj, args, ctx) { 'Hello world!' }\n  end\nend\n\nclass Schema < GraphQL::Schema\n  query QueryType\nend\n\nputs Schema.execute('{ hello }').to_json\n```\n\n其也有对于 Relay 和 Rails 的良好绑定。\n\n#### [Agoo](https://github.com/ohler55/agoo)\n\n一个支持 GraphQL 的高性能 Web 服务器。Agoo 致力于为 GraphQL 提供一个简单易用的 API。\n\n```ruby\nrequire 'agoo'\n\nclass Query\n  def hello\n    'hello'\n  end\nend\n\nclass Schema\n  attr_reader :query\n\n  def initialize\n    @query = Query.new()\n  end\nend\n\nAgoo::Server.init(6464, 'root', thread_count: 1, graphql: '/graphql')\nAgoo::Server.start()\nAgoo::GraphQL.schema(Schema.new) {\n  Agoo::GraphQL.load(%^type Query { hello: String }^)\n}\nsleep\n\n# To run this GraphQL example type the following then go to a browser and enter\n# a URL of localhost:6464/graphql?query={hello}\n#\n# ruby hello.rb\n```\n\n### Rust\n\n - [graphql-rust/juniper](https://github.com/graphql-rust/juniper)：用于 Rust 的 GraphQL 服务端库\n\n### Scala\n\n#### [Sangria](http://sangria-graphql.org/) ([github](https://github.com/sangria-graphql/sangria))：支持 [Relay](https://facebook.github.io/relay/) 的一个 Scala GraphQL 库。\n\n使用的 `sangria` 的一个 GraphQL schema 以及 hello world 查询：\n\n```scala\nimport sangria.schema._\nimport sangria.execution._\nimport sangria.macros._\n\nval QueryType = ObjectType(\"Query\", fields[Unit, Unit](\n  Field(\"hello\", StringType, resolve = _ ⇒ \"Hello world!\")\n))\n\nval schema = Schema(QueryType)\n\nval query = graphql\"{ hello }\"\n\nExecutor.execute(schema, query) map println\n```\n\n### OCaml / Reason\n\n#### [ocaml-graphql-server](https://github.com/andreas/ocaml-graphql-server)：用于 OCaml 和 Reason 的 GraphQL 服务端库。\n\n## GraphQL 客户端\n\n- [C# / .NET](#c#-/-.net-1)\n- [Clojurescript](#clojurescript-1)\n- [Elixir](#elixir-1)\n- [Elm](#elm)\n- [Flutter](#flutter)\n- [Go](#go-1)\n- [Haskell](#haskell-1)\n- [Java / Android](#java-android)\n- [JavaScript](#javascript-1)\n- [Julia](#julia)\n- [Kotlin](#kotlin)\n- [Swift / Objective-C iOS](#swift-objective-c-ios)\n- [Python](#python-1)\n- [R](#r)\n\n### C# / .NET\n\n  - [GraphQL.Client](https://github.com/graphql-dotnet/graphql-client)：一个用于 .NET 的 GraphQL 客户端\n  - [graphql-net-client](https://github.com/bkniffler/graphql-net-client)：基于 .Net 的 GraphQL 客户端基本样例\n  - [SAHB.GraphQLClient](https://github.com/sahb1239/SAHB.GraphQLClient)：GraphQL 客户端，支持从 C# 的类生成查询\n\n### Clojurescript\n\n  - [re-graph](https://github.com/oliyh/re-graph/)：一个在 Clojurescript 中实现的 GraphQL 客户端，支持 websockets。\n\n### Elixir\n\n  - [Neuron](https://github.com/uesteibar/neuron)：Elixir 的 GraphQL 客户端\n  - [common_graphql_client](https://github.com/annkissam/common_graphql_client)：支持 HTTP 和 WebSocket 的 Elixir GraphQL 客户端\n\n### Elm\n\n  - [dillonkearns/elm-graphql](https://github.com/dillonkearns/elm-graphql)：一个库和命令行代码生成器，用于为 GraphQL 入口端点创建类型安全的 Elm 代码。\n\n### Flutter\n\n  - [graphql](https://github.com/zino-app/graphql-flutter#readme)：一个 Flutter 中的 GraphQL 客户端实现。\n\n### Go\n\n  - [graphql](https://github.com/shurcooL/graphql#readme)：一个使用 Go 编写的 GraphQL 客户端实现。\n  - [machinebox/graphql](https://github.com/machinebox/graphql)：用于 GraphQL 的一个优雅的底层 HTTP 客户端。\n\n### Haskell\n\n  - [morpheus-graphql-client](https://github.com/morpheusgraphql/morpheus-graphql)：使用 Haskell 的一个强类型 GraphQL 客户端实现。\n\n### Java / Android\n\n  - [Apollo Android](https://github.com/apollographql/apollo-android)：一个用于 JVM、Android 和 Kotlin native 的 GraphQL 客户端，强类型、带缓存功能。\n  - [Nodes](https://github.com/americanexpress/nodes)：一个 GraphQL JVM 客户端，用于从标准模型定义构建查询。\n\n### JavaScript\n\n  - [Relay](https://facebook.github.io/relay/) ([github](https://github.com/facebook/relay)) ([npm](https://www.npmjs.com/package/react-relay))：Facebook 的框架，用于构建与 GraphQL 后端交流的 React 应用。\n  - [Apollo Client](http://apollographql.com/client/) ([github](https://github.com/apollographql/apollo-client))：一个强大的 JavaScript GraphQL 客户端，设计用于与 React、React Native、Angular 2 或者原生 JavaScript 一同工作。\n  - [graphql-request](https://github.com/prisma/graphql-request)：一个简单灵活的 JavaScript GraphQL 客户端，可以运行于所有的 JavaScript 环境（浏览器，Node.js 和 React Native）—— 基本上是 `fetch` 的轻度封装。\n  - [Lokka](https://github.com/kadirahq/lokka)：一个简单的 JavaScript GraphQL 客户端，可以运行于所有的 JavaScript 环境 —— 浏览器，Node.js 和 React Native。\n  - [nanogql](https://github.com/yoshuawuyts/nanogql)：一个使用模板字符串的小型 GraphQL 客户端库。\n  - [gq-loader](https://github.com/Houfeng/gq-loader)：一个简单的 JavaScript GraphQL 客户端，通过 webpack 加载器让 *.gql 文件作为模块使用。\n  - [AWS Amplify](https://aws.github.io/aws-amplify)：使用云服务进行应用开发的 JavaScript 库，支持 GraphQL 后端和用于处理 GraphQL 数据的 React 组件。\n  - [Grafoo](https://github.com/grafoojs/grafoo)：一个通用的 GraphQL 客户端，具有仅 1.6kb 的多框架的视图层集成。\n  - [urql](https://formidable.com/open-source/urql/) ([github](https://github.com/FormidableLabs/urql))：一个用于 React 的高度可定制且用途广泛的 GraphQL 客户端。\n  - [graphqurl](https://github.com/hasura/graphqurl) ([npm](https://www.npmjs.com/package/graphqurl))：带有自动完成功能、订阅和 GraphiQL 的 curl。也是一个简单通用的 javascript GraphQL 客户端。\n\n### Julia\n\n  - [Diana.jl](https://github.com/codeneomatrix/Diana.jl)：一个 Julia GraphQL 服务端实现.\n\n### Kotlin\n\n  - [graphql-kotlin](https://github.com/ExpediaGroup/graphql-kotlin/)：一组 GraphQL 库，包括一个轻量级、类型安全的 GraphQL HTTP 客户端。\n\n### Swift / Objective-C iOS\n\n  - [Apollo iOS](https://www.apollographql.com/docs/ios/) ([github](https://github.com/apollographql/apollo-ios))：一个用于 iOS 的 GraphQL 客户端，返回查询特定的 Swift 类型，与 Xcode 集成后可以分屏显示你的 Swift 源代码和 GraphQL，并能在行内展示验证错误。\n  - [GraphQL iOS](https://github.com/funcompany/graphql-ios)：一个用于 iOS 的  Objective-C GraphQL 客户端。\n  - [Graphaello](https://github.com/nerdsupremacist/Graphaello)：一个使用 GraphQL 和 Apollo 在 SwiftUI 中编写声明式、类型安全和数据驱动的应用程序的工具\n\n### Python\n\n  - [GQL](https://github.com/graphql-python/gql)：一个 Python 中的 GraphQL 客户端。\n  - [python-graphql-client](https://github.com/prisma/python-graphql-client)：适用于 Python 2.7+ 的简单 GraphQL 客户端。\n  - [sgqlc](https://github.com/profusion/sgqlc)：一个简单的 Python GraphQL 客户端。支持为 GraphQL schema 中定义的类型生成代码。\n\n### R\n\n  - [ghql](https://github.com/ropensci/ghql)：通用的 GraphQL R 客户端。\n   \n## 工具\n\n  - [graphiql](https://github.com/graphql/graphiql) ([npm](https://www.npmjs.com/package/graphiql))：一个交互式的运行于浏览器中的 GraphQL IDE.\n  - [libgraphqlparser](https://github.com/graphql/libgraphqlparser)：一个 C++ 版 GraphQL 查询语言分析器，提供 C 和 C++ API。\n  - [Graphql Language Service](https://github.com/graphql/graphql-language-service)：一个用于构建 IDE 的 GraphQL 语言服务（诊断、自动完成等）的接口。\n  - [quicktype](https://quicktype.io) ([github](https://github.com/quicktype/quicktype))：在 TypeScript、Swift、golang、C#、C++ 等语言中为 GraphQL 查询生成类型。\n  - [GraphQL Code Generator](https://graphql-code-generator.com)：GraphQL 代码生成器具有对自定义插件和模板（如 Typescript 前端和后端、React Hooks、解析器签名等）的灵活支持。\n  - [GraphQL Inspector](https://www.graphql-inspector.com)：比较 schema，验证文档，查找重大更改，查找相似类型，schema 覆盖率等等。\n  - [GraphQL Config](https://www.graphql-config.com)：为你所有的 GraphQL 工具应用同一份配置（支持大多数工具、编辑器和 IDE）。\n  - [GraphQL CLI](https://www.graphql-cli.com)：用于常见 GraphQL 开发工作流程的命令行工具。\n  - [GraphQL Scalars](https://github.com/Urigo/graphql-scalars)：自定义 GraphQL 标量类型的库，用于创建精确的、类型安全的 GraphQL schema。\n  - [GraphQL Tools](https://www.graphql-tools.com)：一组用于快速开发 GraphQL 工具的实用程序（schema 和文档加载，schema 合并等）。\n  - [SOFA](https://github.com/Urigo/sofa)：从你的 GraphQL API 生成 REST API。\n  - [GraphQL-ESLint](https://github.com/dotansimha/graphql-eslint)：将 GraphQL AST 集成到 ESLint 核心中（作为解析器）。\n  - [GraphQL Modules](https://www.graphql-modules.com)：使你可以将后端实现分拆成小型、可重用、易于实现和易于测试的部分。\n  - [GraphQL Mesh](https://www.graphql-mesh.com)：允许你使用 GraphQL 查询语言来访问不运行 GraphQL 的远程 API（也包括那些运行 GraphQL 的远程 API）中的数据。它可以作为其他服务的网关，也可以作为本地 GraphQL schema 运行，以聚合来自远程 API 的数据。\n\n## 服务\n\n  - [Apollo Graph Manage](http://engine.apollographql.com)：一个用于监视 GraphQL 后端的性能和使用的云服务。\n  - [GraphCMS](https://graphcms.com/)：一个 BaaS（后端即服务），它为你配置了一个作为内容编辑工具来处理存储数据的 GraphQL 后端。\n  - [Prisma](https://www.prisma.io) ([github](https://github.com/prisma))：一个 BaaS（后端即服务），它为你的应用程序提供了一个 GraphQL 后端，且具有用于管理数据库和存储数据的强大的 web ui。\n  - [Tipe](https://tipe.io) ([github](https://github.com/tipeio))：一个 SaaS（软件即服务）内容管理系统，允许你使用强大的编辑工具创建你的内容，并通过 GraphQL 或 REST API 从任何地方访问它。\n  - [AWS AppSync](https://aws.amazon.com/appsync/)：完全托管的 GraphQL 服务，包含实时订阅、离线编程和同步、企业级安全特性以及细粒度的授权控制。\n  - [Elide](https://elide.io)：一个 Java 库，可以在任何关系数据库上将 JPA 注释的数据模型公开为 GraphQL 服务。\n  - [Hasura](https://hasura.io) ([github](https://github.com/hasura))：Hasura 连接到你的数据库和微服务，并立即为你提供可用于生产的 GraphQL API。\n  - [FaunaDB](https://docs.fauna.com/fauna/current/graphql)：通过导入 gql schema 创建即时 GraphQL 后端。数据库将为你创建关系和索引，因此你无需编写任何数据库代码即可在几秒钟内查询。Serverless 定价可免费开始使用。\n  - [Back4App](https://www.back4app.com/docs/parse-graphql/graphql-getting-started)：Back4App 是一个后端即服务平台，可帮助你基于 GraphQL 构建和扩展现代应用程序。\n\n## 更多内容\n\n  - [awesome-graphql](https://github.com/chentsulin/awesome-graphql)：一个神奇的社区，维护一系列库、资源等。\n\n"},"nextDoc":null},"pageContext":{"permalink":"/code/","nextPermalink":null,"sideBarData":[{"name":"code","links":[{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/code/code.md","parent":{"relativeDirectory":"code","sourceInstanceName":"content"},"frontmatter":{"title":"Code","permalink":"/code/","next":null,"category":null,"sublinks":null,"sidebarTitle":null,"date":null},"id":"0339cad0-8bd2-5bb3-be8b-0bc3fc6783a6"}]}],"sourcePath":"src/content/code/code.md"}},"staticQueryHashes":["1581580458"]}
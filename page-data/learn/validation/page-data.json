{"componentChunkName":"component---src-templates-doc-tsx","path":"/learn/validation/","result":{"data":{"doc":{"frontmatter":{"title":"验证","date":null,"permalink":"/learn/validation/","byline":null,"guestBio":null,"sublinks":null,"layout":"docs"},"id":"0565a5eb-cc67-5734-ba9e-eb2c441a0f83","rawMarkdownBody":"\n通过使用类型系统，你可以预判一个查询是否有效。这让服务器和客户端可以在无效查询创建时就有效地通知开发者，而不用依赖运行时检查。\n\n对于我们的《星球大战》的案例，[starWarsValidation-test.js](https://github.com/graphql/graphql-js/blob/master/src/__tests__/starWarsValidation-test.js) 这个文件包含了若干对于各种无效查询的演示，它也是一个测试文件，用于检测参考实现的验证器。\n\n```graphql\n# { \"graphiql\": true }\n{\n  hero {\n    ...NameAndAppearances\n    friends {\n      ...NameAndAppearances\n      friends {\n        ...NameAndAppearances\n      }\n    }\n  }\n}\n\nfragment NameAndAppearances on Character {\n  name\n  appearsIn\n}\n```\n\n上面这个查询是有效的。我们来看看一些无效查询……\n\n片段不能引用其自身或者创造回环，因为这会导致结果无边界。下面是一个相同的查询，但是没有显式的三层嵌套：\n\n```graphql\n# { \"graphiql\": true }\n{\n  hero {\n    ...NameAndAppearancesAndFriends\n  }\n}\n\nfragment NameAndAppearancesAndFriends on Character {\n  name\n  appearsIn\n  friends {\n    ...NameAndAppearancesAndFriends\n  }\n}\n```\n\n查询字段的时候，我们只能查询给定类型上的字段。因此由于 `hero` 返回 `Character` 类型，我们只能查询 `Character` 上的字段。因为这个类型上没有 `favoriteSpaceship` 字段，所以这个查询是无效的：\n\n```graphql\n# { \"graphiql\": true }\n# 无效：favoriteSpaceship 不存在于 Character 之上\n{\n  hero {\n    favoriteSpaceship\n  }\n}\n```\n\n当我们查询一个字段时，如果其返回值不是标量或者枚举型，那我们就需要指明想要从这个字段中获取的数据。`hero` 返回 `Character` 类型，我们也请求了其中像是 `name` 和`appearsIn` 的字段；但如果将其省略，这个查询就变成无效的了：\n\n```graphql\n# { \"graphiql\": true }\n# 无效：hero 不是标量，需要指明下级字段\n{\n  hero\n}\n```\n\n类似地，如果一个字段是标量，进一步查询它上面的字段也没有意义，这样做也会导致查询无效：\n\n```graphql\n# { \"graphiql\": true }\n# 无效：name 是标量，因此不允许下级字段查询\n{\n  hero {\n    name {\n      firstCharacterOfName\n    }\n  }\n}\n```\n\n我们之前提到过，只有目标类型上的字段才可查询；当我们查询 `hero` 时，它会返回 `Character`，因此只有 `Character` 上的字段是可查询的。但如果我们要查的是 R2-D2 的 primary function 呢？\n\n```graphql\n# { \"graphiql\": true }\n# 无效：primaryFunction 不存在于 Character 之上\n{\n  hero {\n    name\n    primaryFunction\n  }\n}\n```\n\n这个查询是无效的，因为 `primaryFunction` 并不是 `Character` 的字段。我们需要某种方法来表示：如果对应的 `Character` 是 `Droid`，我们希望获取 `primaryFunction` 字段，而在其他情况下，则忽略此字段。我们可以使用之前引入的“片段”来解决这个问题。先在 `Droid` 上定义一个片段，然后在查询中引入它，这样我们就能在定义了 `primaryFunction` 的地方查询它。\n\n```graphql\n# { \"graphiql\": true }\n{\n  hero {\n    name\n    ...DroidFields\n  }\n}\n\nfragment DroidFields on Droid {\n  primaryFunction\n}\n```\n\n这个查询是有效的，但是有点琐碎；具名片段在我们需要多次使用的时候更有价值，如果只使用一次，那么我们应该使用内联片段而不是具名片段；这同样能表示我们想要查询的类型，而不用单独命名一个片段：\n\n```graphql\n# { \"graphiql\": true }\n{\n  hero {\n    name\n    ... on Droid {\n      primaryFunction\n    }\n  }\n}\n```\n\n这只是验证系统的冰山一角；事实上需要一大套验证规则才能保证 GraphQL 查询的语义意义。规范中的“验证”章节有关于本话题更详细的内容，GraphQL.js 的 [validation](https://github.com/graphql/graphql-js/blob/master/src/validation) 目录包含了规范兼容的 GraphQL 验证器实现代码。\n"},"nextDoc":{"frontmatter":{"title":"执行","permalink":"/learn/execution/"}}},"pageContext":{"permalink":"/learn/validation/","nextPermalink":"/learn/execution/","sideBarData":[{"name":"学习","links":[{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Introduction.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"GraphQL 入门","permalink":"/learn/","next":"/learn/queries/","category":"学习","sublinks":null,"sidebarTitle":"入门","date":null},"id":"217af6f3-a44a-5351-8b0b-a514befda9cb"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Queries.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"查询和变更","permalink":"/learn/queries/","next":"/learn/schema/","category":"学习","sublinks":"字段（Fields）,参数（Arguments）,别名（Aliases）,片段（Fragments）,操作名称（Operation Name）,变量（Variables）,指令（Directives）,变更（Mutations）,内联片段（Inline Fragments）","sidebarTitle":null,"date":null},"id":"0af86a15-fe6e-51e8-9448-8ccf0f5318ff"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Schema.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Schema 和类型","permalink":"/learn/schema/","next":"/learn/validation/","category":"学习","sublinks":"类型系统（Type System）,类型语言（Type Language）,对象类型和字段（Object Types and Fields）,参数（Arguments）,查询和变更类型（The Query and Mutation Types）,标量类型（Scalar Types）,枚举类型（Enumeration Types）,列表和非空（Lists and Non-Null）,接口（Interfaces）,联合类型（Union Types）,输入类型（Input Types）","sidebarTitle":null,"date":null},"id":"3e8d3b3c-c3e5-5aed-9f80-009e9e446f45"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Validation.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"验证","permalink":"/learn/validation/","next":"/learn/execution/","category":"学习","sublinks":null,"sidebarTitle":null,"date":null},"id":"0565a5eb-cc67-5734-ba9e-eb2c441a0f83"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Execution.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"执行","permalink":"/learn/execution/","next":"/learn/introspection/","category":"学习","sublinks":null,"sidebarTitle":null,"date":null},"id":"7e913b82-a77d-57b8-914f-31035755ef87"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Introspection.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"内省","permalink":"/learn/introspection/","next":"/learn/best-practices/","category":"学习","sublinks":null,"sidebarTitle":null,"date":null},"id":"84ba833b-73ca-5aa1-a7f7-89637e035ad9"}]},{"name":"最佳实践","links":[{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-Introduction.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"GraphQL 最佳实践","permalink":"/learn/best-practices/","next":"/learn/thinking-in-graphs/","category":"最佳实践","sublinks":null,"sidebarTitle":"介绍","date":null},"id":"c7c0e36e-a4b0-53f1-9ac7-ef52f07896f2"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-ThinkingInGraphs.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"关于 Graphs 的思考","permalink":"/learn/thinking-in-graphs/","next":"/learn/serving-over-http/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"9f665c8f-58a7-5167-a378-c25b8438940c"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-ServingOverHTTP.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"通过 HTTP 提供服务","permalink":"/learn/serving-over-http/","next":"/learn/authorization/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"7138fa24-001e-5307-b82e-da9310ea9994"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-Authorization.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"授权","permalink":"/learn/authorization/","next":"/learn/pagination/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"82fda3e7-22a0-5bac-9684-864ca66055e6"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-Pagination.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"分页","permalink":"/learn/pagination/","next":"/learn/global-object-identification/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"0001ba04-90f9-545f-8418-deef3908c174"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-NodeInterface.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"全局对象识别","permalink":"/learn/global-object-identification/","next":"/learn/caching/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"40758357-fb23-5aee-b52a-66ab6080c0a1"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-Caching.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"缓存","permalink":"/learn/caching/","next":null,"category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"7d69862f-8b98-56bc-b11e-8c532131021a"}]}],"sourcePath":"src/content/learn/Learn-Validation.md"}},"staticQueryHashes":["1581580458"]}
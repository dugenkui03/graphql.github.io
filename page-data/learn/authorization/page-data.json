{"componentChunkName":"component---src-templates-doc-tsx","path":"/learn/authorization/","result":{"data":{"doc":{"frontmatter":{"title":"授权","heroText":null,"date":null,"permalink":"/learn/authorization/","byline":null,"guestBio":null,"sublinks":null,"layout":"docs","tags":null},"id":"82fda3e7-22a0-5bac-9684-864ca66055e6","rawMarkdownBody":"\n> 将授权逻辑委托给业务逻辑层\n\n授权是一种业务逻辑，描述给定的用户、会话、上下文是否具有执行操作的权限或查看一条数据的权限。例如：\n\n**“只有作者才能看到他们自己的草稿”**\n\n应当在 [业务逻辑层](/learn/thinking-in-graphs/#业务逻辑层) 实施这种行为。在 GraphQL 层中放置授权逻辑是很吸引人的，如下所示：\n\n```javascript\nvar postType = new GraphQLObjectType({\n  name: 'Post',\n  fields: {\n    body: {\n      type: GraphQLString,\n      resolve: (post, args, context, { rootValue }) => {\n        // 只有当用户是帖子的作者时才返回帖子正文\n        if (context.user && (context.user.id === post.authorId)) {\n          return post.body;\n        }\n        return null;\n      }\n    }\n  }\n});\n```\n\n可以看到我们通过检查帖子的 `authorId` 字段是否等于当前用户的 `id` 来定义“作者拥有一个帖子”。你能发现其中的问题吗？我们需要复制这段代码到服务中的每一个入口端点。一旦我们无法保证授权逻辑的完全同步，用户可能在使用不同的 API 时看到不同的数据。我们可以通过确定授权的 [唯一真实来源](/learn/thinking-in-graphs/#业务逻辑层) 来避免这种情况。\n\n在学习 GraphQL 或原型设计时，在解析器内定义授权逻辑是可以接受的。然而，对于生产代码库来说，还是将授权逻辑委托给业务逻辑层。这里有一个例子：\n\n```javascript\n// 授权逻辑在 postRepository 中\nvar postRepository = require('postRepository');\n\nvar postType = new GraphQLObjectType({\n  name: 'Post',\n  fields: {\n    body: {\n      type: GraphQLString,\n      resolve: (post, args, context, { rootValue }) => {\n        return postRepository.getBody(context.user, post);\n      }\n    }\n  }\n});\n```\n\n在上面的例子中，我们看到业务逻辑层要求调用者提供一个用户对象。如果您使用 GraphQL.js，您应当在解析器的 `context` 参数或是第四个参数中的 `rootValue` 上填充 User 对象。\n\n我们建议将完全混合 <sup>[\\[1\\]](#note1)</sup> 的 User 对象传递给业务逻辑层，而非传递不透明的 token 或 API 密钥。这样，我们可以在请求处理管道的不同阶段处理 [身份验证](/graphql-js/authentication-and-express-middleware/) 和授权的不同问题。\n\n<ol>\n<li><a name=\"note1\"></a> “混合（hydrated）”一个对象是指：对一个存储在内存中且尚未包含任何域数据（“真实”数据）的对象，使用域数据（例如来自数据库、网络或文件系统的数据）进行填充。 <a href=\"https://stackoverflow.com/questions/6991135/what-does-it-mean-to-hydrate-an-object\">*</a></li>\n</ol>\n"},"nextDoc":{"frontmatter":{"title":"分页","permalink":"/learn/pagination/"}}},"pageContext":{"permalink":"/learn/authorization/","nextPermalink":"/learn/pagination/","sideBarData":[{"name":"学习","links":[{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Introduction.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"GraphQL 入门","permalink":"/learn/","next":"/learn/queries/","category":"学习","sublinks":null,"sidebarTitle":"入门","date":null,"tags":null},"id":"217af6f3-a44a-5351-8b0b-a514befda9cb"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Queries.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"查询和变更","permalink":"/learn/queries/","next":"/learn/schema/","category":"学习","sublinks":"字段（Fields）,参数（Arguments）,别名（Aliases）,片段（Fragments）,操作名称（Operation Name）,变量（Variables）,指令（Directives）,变更（Mutations）,内联片段（Inline Fragments）","sidebarTitle":null,"date":null,"tags":null},"id":"0af86a15-fe6e-51e8-9448-8ccf0f5318ff"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Schema.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Schema 和类型","permalink":"/learn/schema/","next":"/learn/validation/","category":"学习","sublinks":"类型系统（Type System）,类型语言（Type Language）,对象类型和字段（Object Types and Fields）,参数（Arguments）,查询和变更类型（The Query and Mutation Types）,标量类型（Scalar Types）,枚举类型（Enumeration Types）,列表和非空（Lists and Non-Null）,接口（Interfaces）,联合类型（Union Types）,输入类型（Input Types）","sidebarTitle":null,"date":null,"tags":null},"id":"3e8d3b3c-c3e5-5aed-9f80-009e9e446f45"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Validation.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"验证","permalink":"/learn/validation/","next":"/learn/execution/","category":"学习","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"0565a5eb-cc67-5734-ba9e-eb2c441a0f83"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Execution.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"执行","permalink":"/learn/execution/","next":"/learn/introspection/","category":"学习","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"7e913b82-a77d-57b8-914f-31035755ef87"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Introspection.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"内省","permalink":"/learn/introspection/","next":"/learn/best-practices/","category":"学习","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"84ba833b-73ca-5aa1-a7f7-89637e035ad9"}]},{"name":"最佳实践","links":[{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-Introduction.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"GraphQL 最佳实践","permalink":"/learn/best-practices/","next":"/learn/thinking-in-graphs/","category":"最佳实践","sublinks":null,"sidebarTitle":"介绍","date":null,"tags":null},"id":"c7c0e36e-a4b0-53f1-9ac7-ef52f07896f2"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-ThinkingInGraphs.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"关于 Graphs 的思考","permalink":"/learn/thinking-in-graphs/","next":"/learn/serving-over-http/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"9f665c8f-58a7-5167-a378-c25b8438940c"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-ServingOverHTTP.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"通过 HTTP 提供服务","permalink":"/learn/serving-over-http/","next":"/learn/authorization/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"7138fa24-001e-5307-b82e-da9310ea9994"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-Authorization.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"授权","permalink":"/learn/authorization/","next":"/learn/pagination/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"82fda3e7-22a0-5bac-9684-864ca66055e6"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-Pagination.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"分页","permalink":"/learn/pagination/","next":"/learn/global-object-identification/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"0001ba04-90f9-545f-8418-deef3908c174"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-NodeInterface.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"全局对象识别","permalink":"/learn/global-object-identification/","next":"/learn/caching/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"40758357-fb23-5aee-b52a-66ab6080c0a1"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-Caching.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"缓存","permalink":"/learn/caching/","next":null,"category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null,"tags":null},"id":"7d69862f-8b98-56bc-b11e-8c532131021a"}]}],"sourcePath":"src/content/learn/BestPractice-Authorization.md"}},"staticQueryHashes":["1581580458","4162432391"]}